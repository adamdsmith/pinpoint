#' Plot processed Swift fixes from PinPoint Host software output
#'
#' This function plots fixes from either (1) the text file generated by the
#'  PinPoint Host software or (2) the data frame generated by \code{\link{read_pp_swift}}
#'  and generates a basic interactive map of fixes using \code{\link[leaflet]{leaflet}}
#'  with a separate overlay group for each distinct tag ID (in the case a combined data
#'  frame of \code{\link{read_pp_swift}} output is passed to the function).  Failed GPS
#'  fix attempts are removed automatically.  Users can optionally filter GPS fixes by the
#'  reported dilution of precision `max_hdop` or the number of satellites `min_sats`.
#'  Limited experimentation finds fixes with HDOP <= 4 and at least 4 satellites to be of
#'  adequate locational quality (usually within 20 m).  These are the defaults.
#'
#' @param pp_df a `pp_df` object (i.e., a `data.frame` created by \code{\link{read_pp_swift}})
#' @param out_tz character string indicating the desired output \code{\link[base]{timezone}}
#'  of the GPS fixes.  Datetimes will be converted from the standard GMT time zone of
#'  PinPoint fixes. Default is America/New_York.
#' @param max_hdop numeric scalar indicating the maximum dilution of precision (default is
#'  <= 4) to accept a GPS fix as valid.
#' @param min_sats numeric/integer scalar indicating the minimum number of satellites
#'  required (default is 4) to accept a GPS fix as valid.
#' @import leaflet
#' @export

plot.pp_df <- function(pp_df, out_tz = "America/New_York",
                          max_hdop = 4, min_sats = 4)
{
  if (inherits(pp_df, "data.frame")) {
    if (!any(c("tag_id", "lat", "lon", "hdop", "n_sats") %in% names(pp_df)))
      stop("At least one required column is missing.\n",
           "Was the output created by the `read_pp_swift` function?")
  } else stop("Input is not a `data.frame`. Run `read_pp_swift` function to generate input.")

  pp_df <- pp_df %>%
    dplyr::filter_(~status == "valid") %>%
    dplyr::filter_(~hdop <= max_hdop) %>%
    dplyr::filter_(~n_sats >= min_sats)

  # Set up separate overlays/colors by tag
  tags <- unique(pp_df$tag_id)
  colors = viridis::viridis(length(tags))
  tag_colors = colorFactor(palette = colors, domain = pp_df$tag_id)

  p <- leaflet(pp_df) %>%

    # Base map group
    addProviderTiles("Esri.WorldImagery", group = "Aerial",
                     options = tileOptions(minZoom=3, maxNativeZoom=19,
                                                    maxZoom=22)) %>%
    addProviderTiles("Stamen.Terrain", group = "Terrain",
                     options = tileOptions(minZoom=3))

    for (tag in tags) {
    d <- pp_df[pp_df$tag_id == tag, ]
    p <- p %>% addCircleMarkers(data = d, lng = ~lon, lat = ~lat,
                                fillColor = ~tag_colors(tag_id),
                                fillOpacity = 1, radius = 5,
                                color = "black", weight = 1, opacity = 1,
                                popup = ~paste(paste("Tag ID:", tag_id),
                                               paste("# Sats:", n_sats),
                                               paste("HDOP:", hdop),
                                               fix_local, sep = "<br/>"),
                                group = tag)
    }

  p %>% addLayersControl(baseGroups = c("Aerial", "Terrain"),
                         overlayGroups = tags,
                         options = layersControlOptions(collapsed = FALSE)) %>%
    addScaleBar(position = "bottomright")

}
